type t

type selections
type diagnostics

val create :
  ?prefer_oldest:bool ->
  constraints:(Cudf_types.pkgname * (Cudf_types.relop * Cudf_types.version)) list ->
  Cudf.universe ->
  t
(** [create ~constraints universe] is a solver that gets candidates from [universe],
    filtering them using [constraints].

    @param prefer_oldest if [true] the solver is set to return the least
    up-to-date version of each package, if a solution exists. This is [false] by
    default.
    @before 0.4 the [prefer_oldest] parameter did not exist. *)

val solve :
  t ->
  (Cudf_types.pkgname * [`Essential | `Recommended]) list ->
  (selections, diagnostics) result
(** [solve t packages] finds a compatible set of package versions that
    includes all packages in [packages] according to their requirement tag,
    and their required dependencies if needed. *)

val packages_of_result : selections -> (Cudf_types.pkgname * Cudf_types.version) list

val diagnostics : ?verbose:bool -> diagnostics -> string
(** [diagnostics d] is a message explaining why [d] failed, generated by
    performing another solve which doesn't abort on failure. *)

module Raw_diagnostics : sig
  type restriction = {
    kind : [`Ensure | `Prevent];
    expr : (Cudf_types.relop * Cudf_types.version) list;
  }

  type role =
    | Real of Cudf_types.pkgname
    | Virtual of impl list
  and real_impl = {
    pkg : Cudf.package;
    requires : dependency list;
  }
  and dependency = {
    drole : role;
    importance : [`Essential | `Recommended | `Restricts];
    restrictions : restriction list;
  }
  and impl =
    | RealImpl of real_impl
    | VirtualImpl of dependency list
    | Reject of (Cudf_types.pkgname * Cudf_types.version)
    | Dummy

  type rejection_reason =
    | ModelRejection of Cudf_types.vpkg
    | FailsRestriction of restriction
    | DepFailsRestriction of dependency * restriction
    | ConflictsRole of role
    | DiagnosticsFailure of string

  type reject = impl * rejection_reason
  type candidates = reject list * [`All_unusable | `No_candidates | `Conflicts]

  type outcome =
    | SelectedImpl of impl
    | RejectedCandidates of candidates

  type note =
    | UserRequested of restriction
    | ReplacesConflict of role
    | ReplacedByConflict of role
    | Restricts of role * impl * restriction list
    | Feed_problem of string

  type t = {
    role : role;
    outcome : outcome;
    notes : note list;
  }

  val get : diagnostics -> t list
end
